# sk_maze

A program that generates and solves mazes using different algorithms, such as depth-first search or breadth-first search.

## List of inspirational ideas

The list of ideas to serve as inspiration.

- The program generates a maze using a chosen algorithm. There are several algorithms that can be used to generate mazes, such as the depth-first search and breadth-first search algorithms. The algorithm creates a series of interconnected rooms and corridors, with some of the rooms designated as "dead ends" that do not lead anywhere.

- The program displays the maze to the user. This could be done using a graphical user interface (GUI) or by printing the maze to the console.

- The user can then choose an algorithm to solve the maze. The program uses the chosen algorithm to find a path from the start of the maze to the end.

- The program displays the solved maze to the user, highlighting the path from start to finish.

- Different types of mazes, such as perfect mazes (where every room has exactly one entrance and one exit) or imperfect mazes (where some rooms have more than one entrance or exit).

- A level editor that allows the user to create their own mazes.

- A "hint" function that shows the next step in the solution.

- A "solve" function that automatically solves the maze using the chosen algorithm.

- Different types of mazes: In addition to perfect mazes (where every room has exactly one entrance and one exit) and imperfect mazes (where some rooms have more than one entrance or exit), you could also add other types of mazes to the program, such as circular mazes (where the path forms a loop) or multimaze puzzles (where the user must solve multiple connected mazes at once).

- Customizable maze size and complexity: You could allow the user to specify the size and complexity of the maze they want to generate or solve. For example, they might be able to choose the number of rows and columns in the maze, or the percentage of dead ends in the maze.

- Multiple solving algorithms: You could add multiple algorithms that the user can choose from to solve the maze. For example, in addition to depth-first search and breadth-first search, you could include other algorithms such as A\* search or Dijkstra's algorithm.

- Obstacles and special tiles: You could add obstacles or special tiles to the maze that the user must navigate around or interact with in order to solve the maze. For example, you might include walls that the user cannot pass through, or doors that can only be opened by finding a key.

- Multiplayer mode: You could allow multiple users to play the game at the same time, either by solving the same maze or by competing to solve different mazes as quickly as possible.

- Saving and loading mazes: You could allow the user to save their mazes to a file and load them back into the program at a later time. This could be useful for creating and sharing custom mazes with others.
